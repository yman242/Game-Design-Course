<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!global.tutorial)
{
    global.tutorial = true;
    room_goto(room_Tutorial);
}

global.selectedShip = 0;

global.buttonTier = 0;//Used to determine how many buttons we have in place in terms of layers.

scaleSize = 1.5;//scaled size of screen
scrollSpeed = 2; //Speed of the background.

view_wview[view_current] *= scaleSize;
view_hview[view_current] *= scaleSize;

global.waves = 2; //How many waves of enemies there will be.
currentWave = 0;

waveTotals[0,0] = 3;// Controls the monsters per wave. x is the wave number, y is the enemy type.
waveTotals[1,0] = 5;
monsters = 0; //An array to hold the monsters

global.onField = 0; //How many ships currently on field.

global.moveSpeed = 10; //How fast ships will move to the battle line

global.howFar = room_width*1/4; //Default value to push the ships by.

global.linePosition = (view_wview[view_current] - sprite_get_width(sprite_UIOverlay))/1.5;//room_width/4;

global.battleState = 0; //0 is placing ships, 1 is placing new wave, 2 is moving, 3 is fighting.

looper = room_height/32; //Used to draw the wall.

planetDestroyer = instance_create(0,view_hview[view_current]/2,obj_PlanetDestroyer);
planetDestroyer.y -= sprite_get_height(planetDestroyer.sprite_index)/2;

attackedPlanet = instance_create(view_wview[view_current],view_hview[view_current]/2,MonsterPlanet); //makes the planet being attacked.
attackedPlanet.x -= sprite_get_width(attackedPlanet.sprite_index)*3/4;//Puts the planet on screen and then pushes it back.
attackedPlanet.x += (sprite_get_width(attackedPlanet.sprite_index)/4)*global.waves;
attackedPlanet.y -= sprite_get_height(attackedPlanet.sprite_index)/2;

xHolder = view_wview[view_current] - sprite_get_width(sprite_Button);
yHolder = sprite_get_height(sprite_Button)/2;
incrementHolder = yHolder*2+32;

for(i=0;i&lt;global.shipMax;i++)
{
    if(global.fleet[i].shipType == 0)
    {
        buttons[i] = instance_create(xHolder,yHolder,obj_ShipButton1);
        yHolder += incrementHolder;
    }
    else if(global.fleet[i].shipType == 1)
    {
        buttons[i] = instance_create(xHolder,yHolder,obj_ShipButton2);
        yHolder += incrementHolder;
    }
    else if(global.fleet[i].shipType == 2)
    {
        buttons[i] = instance_create(xHolder,yHolder,obj_ShipButtonCruiser);
        yHolder += incrementHolder;
    }
    else if(global.fleet[i].shipType == 3)
    {
        buttons[i] = instance_create(xHolder,yHolder,obj_ShipButtonBattleship);
        yHolder += incrementHolder;
    }
    else // shipType == 4
    {
        buttons[i] = instance_create(xHolder,yHolder,obj_ShipButtonMissleship);
        yHolder += incrementHolder;
    }
    
    buttons[i].commander = global.fleet[i];
}

instance_create(xHolder,yHolder,obj_Go);


whichWay = 0; //Not Implemented yet, but will allow control of directions.
/*
0 = right
1 = down
2 = left
3 = up
*/




</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.battleState == 1)
{   
    currentWave++;
    if(currentWave&gt;global.waves)
    {
        // Conquered the planet
        global.currentlyInvadingPlanet.isControlled = true;
        
        room_goto(room_Win);
    }
    else
    {   
        if(currentWave-global.waves==0)
        {
            global.destroyable = true;
        }
        for(k=0;k&lt;waveTotals[currentWave-1,0];k++)
        {
            monsters[k] = instance_create(view_wview+random(view_wview - global.linePosition*1.2), random(view_hview),MonsterController);
            /*monsters[k].stratPosition = scriptMonsterStratLocations(monsters[k].strategyType);
            monsters[k].shipType = floor(random(5))+1;
            
            if(monsters[k].shipType==1) //Frigate
            {
                monsters[k].numOfShips = 10;
            }
            else if(monsters[k].shipType==2) //Cruiser
            {
                monsters[k].numOfShips = 5;
            }
            else if(monsters[k].shipType==3) //Destroyer
            {
                monsters[k].numOfShips = 7;
            }
            else if(monsters[k].shipType==4) //Missleship
            {
                monsters[k].numOfShips = 5;
            }
            else if(monsters[k].shipType==5) //Battleship
            {
                monsters[k].numOfShips = 4;
            }
            
            monsters[k].ships = scriptMonsterControllerSetup(monsters[k].shipType,monsters[k].numOfShips,monsters[k].stratPosition,monsters[k].x,monsters[k].y,monsters[k].id);
        */}
        
        monsters = scriptUpdateArray(monsters);
        attackedPlanet.goal = attackedPlanet.x - (sprite_get_width(attackedPlanet.sprite_index)/4);
        global.battleState = 2;
    }
}
else if(global.battleState == 2)
{
    stop = false;
    
    for(i = 0; i&lt;array_length_1d(monsters);i++)
    {
        for(k = 0;k&lt;array_length_1d(monsters[i].ships);k++)
        {
            if(monsters[i].ships[k].x &lt;= global.linePosition*1.1)
            {
                stop = true;
                break;
            }
        }
    }
    if(stop)
    {
        for(i = 0; i&lt;array_length_1d(monsters);i++)
        {
            for(k = 0;k&lt;array_length_1d(monsters[i].ships);k++)
            {
                monsters[i].ships[k].speed = 0;
            }
            
        }
        global.battleState = 3;
    }
}
if(global.battleState&gt;0)
{
    background_hspeed[1] = -scrollSpeed;
    if(!instance_exists(Monster)) //Wave over
    {
        global.battleState = 1;
    }
    else if(!instance_exists(Ship)) //Lost
    {
        room_goto(room_Lose);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.battleState == 0)
{
    for(i = 0; i&lt;=looper; i++) //Draws a wall.
    {
        draw_sprite(sprite_Line,0,global.linePosition,i*32);
    }
    
    draw_sprite_stretched(sprite_UIOverlay,0,view_wview[view_current] - sprite_get_width(sprite_UIOverlay),0,sprite_get_width(sprite_UIOverlay),view_wview[view_current]);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
